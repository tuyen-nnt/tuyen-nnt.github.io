<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<link rel="icon" href="/assets/images/logo.png">

<title>Tìm hiểu Network | Tuyen Nguyen</title>

<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Tìm hiểu Network | My Blog</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Tìm hiểu Network" />
<meta name="author" content="tuyennnt" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="I. Mô hình mạng 5 tầng Tầng 1: Physical" />
<meta property="og:description" content="I. Mô hình mạng 5 tầng Tầng 1: Physical" />
<link rel="canonical" href="https://tuyen-nnt.github.io/network/" />
<meta property="og:url" content="https://tuyen-nnt.github.io/network/" />
<meta property="og:site_name" content="My Blog" />
<meta property="og:image" content="https://tuyen-nnt.github.io/assets/images/network-layer.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-10-18T00:00:00+07:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:image" content="https://tuyen-nnt.github.io/assets/images/network-layer.png" />
<meta property="twitter:title" content="Tìm hiểu Network" />
<script type="application/ld+json">
{"mainEntityOfPage":{"@type":"WebPage","@id":"https://tuyen-nnt.github.io/network/"},"url":"https://tuyen-nnt.github.io/network/","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://tuyen-nnt.github.io/assets/images/ava.png"},"name":"tuyennnt"},"image":"https://tuyen-nnt.github.io/assets/images/network-layer.png","author":{"@type":"Person","name":"tuyennnt"},"description":"I. Mô hình mạng 5 tầng Tầng 1: Physical","dateModified":"2021-10-18T00:00:00+07:00","datePublished":"2021-10-18T00:00:00+07:00","headline":"Tìm hiểu Network","@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    
<link href="/assets/css/prism.css" rel="stylesheet">

<link href="/assets/css/theme.css" rel="stylesheet">

<script src="/assets/js/jquery.min.js"></script>

</head>




<body>
	<!-- defer loading of font and font awesome -->
	<noscript id="deferred-styles">
		<link href="https://fonts.googleapis.com/css?family=Sen:400,700&display=swap" rel="stylesheet">
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	</noscript>

<!-- Begin Sidebar Navigation
================================================== -->

<div class="sidebar">    
</div>   
<div class="nav-icon">
    <div class="hamburger-bar"></div>
</div>
<div id="blackover-nav" class="blackover"></div>
<nav id="menu">
    <ul>
        <h3>Navigation</h3>
        <li><a href="/">Home</a></li>
        <li><a href="/about">About</a></li>
        <li><a href="/authors">Contributors <span class="badge badge-primary">new</span></a></li>
        <li><a target="_blank" href="https://bootstrapstarter.com/jekyll-theme-memoirs/">Get Memoirs</a></li>      
        <li><a href="/contact">Contact</a></li>       
    </ul>   
</nav>

<script src="/assets/js/lunr.js"></script>

<style>
    
</style>

<div class="wrap-search">
    <div class="d-flex align-items-center ml-auto">
        <i class="fas fa-search show-search"></i>
        <form class="bd-search ml-3" onSubmit="return lunr_search(document.getElementById('lunrsearch').value);">
            <input type="text" class="form-control bigradius text-small launch-modal-search" id="lunrsearch" name="q" maxlength="255" value="" placeholder="Type and enter..."/>
        </form>
    </div>
</div>

<div id="lunrsearchresults">
    <ul></ul>
</div>

<script src="/assets/js/lunrsearchengine.js"></script>


<!-- End Sidebar Navigation
================================================== -->

<div class="site-content ">

<div class="container">

    <!-- Site Logo/Name
    ================================================== -->
   
    <a class="navbar-brand" href="/">
        <img src="/assets/images/ava.png" alt="Tuyen Nguyen">
    </a>  
   

    <!-- Site Tag
    ================================================== -->
    

    <!-- Content
    ================================================== -->
    <div class="main-content">
        <div class="entry-header">
    <!-- Post Title -->
    <h1 class="posttitle">Tìm hiểu Network</h1>
    <!-- Author & Date  Box -->
    
    
    <div class="d-flex align-items-center mt-4">
        <div>
            
            <img class="author-thumb" src="/assets/images/ava.png" alt="Tuyen">
            
        </div>            
        <div>
        Written by Tuyen on 
        <span class="post-date"><time class="post-date" datetime="2021-10-18">18 Oct 2021</time></span>           
        
        </div>            
    </div>
    
</div>

<!-- Adsense under title if enabled from _config.yml (change your pub id and slot) -->


<!-- Featured Image -->

<div class="entry-featured-image">
    
    <img class="featured-image " src="/assets/images/network-layer.png" alt="Tìm hiểu Network">
    
</div>


<!-- Content -->
<!-- Post, Page Content
================================================== -->
<div class="article-post">
    <!-- Toc if any -->
    
    <!-- End Toc -->
    <h2 id="i-mô-hình-mạng-5-tầng">I. Mô hình mạng 5 tầng</h2>
<p><img src="/assets/images/five-layer-network.png" alt="" /></p>

<ul>
  <li>Tầng 1: Physical</li>
</ul>

<p>Ví dụ như dây cáp mạng, hay các đầu nối, tín hiệu gửi để kết nối các máy tính với nhau. Ngoài ra tầng này còn mô tả cách tín hiệu được gửi qua các kết nối vật lý này.</p>

<ul>
  <li>Tầng 2: Data Link</li>
</ul>

<p>Dùng để diễn giải các tín hiệu của tầng 1 một cách chung chung để các thiết bị mạng có thể giao tiếp.
Có nhiều giao thức ở tầng này nhưng phổ biến nhất là Ethernet, có nhiệm vụ nhận dữ liệu và truyền đến các nodes trên cùng 1 mạng hoặc link. 
Tầng này nhận dữ liệu trên 1 đường liên kết đơn.</p>

<ul>
  <li>Tầng 3: Network (or Internet)
 <img src="/assets/images/network-layer.png" alt="" />
 Là tầng cho phép các mạng khác nhau liên kết với nhau thông qua các thiết bị router (bộ định tuyến). 
 Tập hợp các mạng kết nối với nhau thông qua router gọi là Internetwork (mạng liên kết). Mạng liên kết phổ biến nhất là <code>Internet</code> :D.
 Tầng này chịu trách nhiệm nhận dữ liệu được phân phối từ 1 tập hợp các mạng.
Giao thức phổ biến nhất ở tầng này là giao thức IP (Internet protocol).</li>
</ul>

<p>Một phần mềm mạng gồm <code>Client</code> và <code>Server</code>:</p>

<ul>
  <li>Client gửi request</li>
  <li>Server thì gửi về response</li>
</ul>

<p>Một node có thể chạy nhiều chương trình client hoặc server cùng lúc.
Kiểu như ở client (server host) của bạn cùng thao tác nhiều chương trình cùng lúc để request (như mail, trình duyệt web), thì server ngoài cũng có thể chạy nhiều chương trình để trả về response cho bạn.</p>

<ul>
  <li>Tầng 4: Transport</li>
</ul>

<p>Trong khi tầng Network cung cấp dữ liệu giữa 2 node riêng lẻ thì tầng Transport có nhiệm vụ phân loại ra chương trình client hay server nào có nhiệm vụ nhận dữ liệu đó.</p>

<p>Giao thức phổ biến nhất ở tầng này chính là TCP (Transmission Control Protocol). Người ta hay gọi theo cụm là TCP IP.</p>
<blockquote>
  <p>Nhưng TCP IP ko phải là tên gọi của 1 giao thức, nó chỉ là tên gọi chung kết hợp của giao thức ở tầng 3 và tầng 4. Mỗi giao thức đều có công dụng khác nhau.</p>
</blockquote>

<p>Ngoài ra có 1 giao thức thuộc tầng 4 transport cũng sử dụng giao thức IP tầng 3 để truyền tải dữ liệu. Đó là giao thức UDP (User Datagram Protocol). Nhưng giao thức này không đảm bảo độ tin cậy bằng TCP, mình sẽ nói thêm ở mục sau.</p>

<p>Tóm lại, các giao thức ở tầng này hầu hết có nhiệm vụ đảm bảo dữ liệu được truyền tải đến “đúng” các ứng dụng đang chạy trên các nút đó.</p>

<ul>
  <li>Tầng 5: Application</li>
</ul>

<p>Giao thức phổ biến ở tầng này là HTTP (cho phép chúng ta duyệt web), SMTP (gửi/nhận email), etc..</p>

<h4 id="tóm-tắt-giải-thích-1-cách-dễ-hiểu-hơn">Tóm tắt: Giải thích 1 cách dễ hiểu hơn:</h4>
<p><img src="/assets/images/layer-actual.png" alt="" /></p>

<ul>
  <li>Tầng 1: Chiếc xe tải</li>
  <li>Tầng 2: Mô tả cách xe tải đi từ giao lộ này đến giao lộ kia.</li>
  <li>Tầng 3: Xác định đường để đi từ địa chỉ A đến địa chỉ B để giao hàng.</li>
  <li>Tầng 4: Đảm bảo là tài xế biết cách gõ cửa nhà để biết đến đúng địa chỉ nhà rồi và thông báo ra nhận gói tin.</li>
  <li>Tầng 5: Chính là nội dung của gói hàng (dữ liệu) !</li>
</ul>

<h4 id="có-thể-bạn-chưa-biết">Có thể bạn chưa biết?</h4>

<ul>
  <li>Ngoài model 5 tầng còn nhiều model khác. Nổi tiếng nhất là OSI model (7 tầng), khác với loại 5 tầng mà chúng ta học ở chỗ tầng 5 được tách ra 3 tầng.</li>
  <li>TCP/IP truyền thống chỉ có 4 tầng vì Tầng 1 và tầng 2 được gộp làm 1. Về cơ bản cái truyền thống 4 tầng và 5 tầng hiện nay không khác nhau là mấy.</li>
  <li>Chúng ta có thể tìm hiểu thêm về OSI Model tại đây:
```
https://www.sans.org/reading-room/whitepapers/standards/osi-model-overview-543</li>
</ul>

<p>https://en.wikipedia.org/wiki/OSI_model</p>
<pre><code>
## II. Tầng 1 - Các thiết bị mạng cơ bản

### Cable
Dùng để kết nối các thiết bị với nhau và cho phép truyền dữ liệu thông qua nó.

Giúp tạo kết nối mạng đơn giữa 1 điểm với 1 điểm.

Có 2 loại:

* Copper cable: Cat3, Cat5, Cat5e, Cat6,...
![](cooper-cable.png)
	* Các cable đời mới hơn như Cat5e, Cat6 tốt hơn trong việc truyền dữ liệu nhiều hơn và chính xác hơn do chúng có thông số kỹ thuật nâng cao và lõi xoắn của chúng được cấu tạo khác đi để giảm sự xuyên âm (crosstalk- khi mà xung điện trên 1 dây được phát hiện trên 1 dây khác) giúp giảm tình trạng đầu nhận dữ liệu không hiểu được dữ liệu gây ra lỗi mạng.
	* Gửi giao tiếp dữ liệu nhị phân qua dây đồng bằng cách thay đổi điện áp giữa 2 phạm vi. Hệ thống ở đầu nhận dữ liệu sẽ dịch sự thay đổi điện áp này thành dữ liệu nhị phân 0-1. Sau đó từ dữ liệu 0-1 này sẽ được dịch sang các loại dữ liệu khác nhau.
	* Sử dụng áp điện để biểu diễn dữ liệu dưới dạng 0-1

* Fiber optic
	* Sử dụng xung ánh sáng để biểu diễn dữ liệu dưới dạng 0-1.
	* Được dùng ưu tiên cho các môi trường có nhiều nhiễu điện từ.
	* Vận chuyển dữ liệu nhanh hơn, khoảng cách xa hơn mà khó làm mất dữ liệu tiềm ẩn hơn.
	* Đắt và dễ vỡ hơn.
	
	
### Hub &amp; Switch 
Là những thiết bị giúp kết nối các máy tính trong cùng 1 mạng, thường gọi là mạng LAN (mạng cục bộ) 

#### Hub
1 thiết bị bất kỳ trong mạng lưới của hub khi truyền dữ liệu tới hub sẽ kết nối đến tất cả các máy tính khác mà cùng được kết nối với hub. 

![](/assets/images/hub.png) 

Các máy tính nhận dữ liệu có hệ thống riêng để xác định xem dữ liệu đó có đúng là dữ liệu mà nó có nhiệm vụ nhận hay không. Nếu không thì trả về không, nếu có thì thông báo nhận thành công.

Cơ chế này gây ra nhiều tiếng ồn (noise) tạo ra cái gọi là collision domain.

Collision domain:

* Một phân đoạn mạng mà chỉ có 1 thiết bị có thể giao tiếp tại 1 thời điểm.
![](/assets/images/collision.png) 

* Nếu nhiều hệ thống (máy tính) cố gắng gởi dữ liệu cùng 1 lúc, các xung điện được gởi qua cáp (cable) có thể gây nhiễu lẫn nhau.
Khiến cho các hệ thống phải chờ đợi một khoảng thời gian yên tĩnh trước khi cố gắng gửi dữ liệu lần nữa.

&gt; Điều này làm chậm truyền thông mạng nên hiện nay Hub không còn được dùng phổ biến.

### Switch
Mô hình hoạt động tương đối giống Hub, khác biệt ở chỗ:

* Hub ở layer 1, Switch ở layer 2 (Data Link device) 
* Do đó Switch có thể kiểm tra dữ liệu của giao thức Ethernet được gửi đi xung quanh network. 
=&gt; Switch có thể xác định hệ thống (máy tính) nào thuộc về dữ liệu đó mà chỉ gửi thẳng đến hệ thống đó thôi.

![](/assets/images/switch.png)

&gt; Điều này giúp loại bỏ hoàn toàn kích thước của collision domain trong network.
Gíup giảm sự truyền tải lại và tăng thông lượng tổng thể.

### Router
Là thiết bị biết các forward dữ liệu giữa các mạng độc lập với nhau.

![](/assets/images/router.png)

* Hoạt động ở lớp thứ 3 (Network)

* Cũng giống như switch, router có thể kiểm tra dữ liệu IP để xác định địa chỉ cần gửi dữ liệu đến.

* Router chứa 1 số bảng nội bộ chứa các thông tin về định tuyến traffic (lưu lượng truy cập) giữa nhiều mạng khác nhau trên thế giới. Phổ biến là các router gia đình hoặc văn phòng nhỏ. Mục đích của các bộ định tuyến nhỏ này chỉ để lấy lưu lượng truy cập có nguồn gốc từ trong nhà hoặc văn phòng nhỏ sử dụng LAN và chuyển tiếp nó đến ISP (nhà cung cấp dịch vụ Internet)

![](/assets/images/router-isp.png)

* ISP là một loại router phức tạp hơn nhiều, nó sẽ tiếp quản traffic từ router nhỏ. Router này gọi là router lõi, tạo thành xương sống của Internet, chịu trách nhiệm về cách gửi và nhận dữ liệu khắp thế giới mỗi ngày.

* ISP tiếp nhận rất nhiều traffic và phải xử lý việc quyết định nơi nào là nơi gửi traffic này đến. Core router này thường có nhiều kết nối đến nhiều core router khác bằng giao thức BGP (Border Gateway Protocol) giúp chúng tìm hiểu xem đường nào là tối ưu nhất để chuyển lưu lượng truy cập đến.

&gt; Khi bạn mở trình duyệt truy cập đến 1 web server bất kỳ, traffic giữa máy tính và web server có thể đã đi qua hàng chục router khác nhau. 
Các Router là những hướng dẫn viên toàn cầu giúp đưa traffic đến đúng nơi.


## Server và Client

Nodes: là từ dùng để gọi chung cho các thiết bị trong network ở trên, có thể là máy tính, server, client hay router,...

Server: là node có nhiệm vụ cung cấp data cho client, còn được dùng để chỉ mục đích chính của node trên mạng.

Client: là node request data.

Đôi khi 1 node vừa làm server vừa là client. Ví dụ như Email server, vừa cung cấp data về email cho client, mà vừa là 1 client gửi yêu cầu đến DNS server và được DNS trả data về.

=&gt; Hầu hết các thiết bị không hoàn toàn là 1 server hay 1 client, mà đảm nhận 1 trong 2 vị trí trên ở 1 thời điểm.

![](/assets/images/server-client.png)


## III. Tầng 2 - Data Link Layer

### Ethernet 
* Là protocol mạng phổ biến nhất ở tầng 2 để gửi dữ liệu qua các liên kết riêng lẻ. (còn Wi-Fi thì dạng khác)
* Là phương tiện giúp trừu tượng hóa tầng 1 (vật lý hay phần cứng) để các tầng khác có thể dễ tiếp cận sử dụng.
* Chịu trách nhiệm về các thông tin kết nối, liên kết thiết bị để các tầng trên dựa vào. Vì vậy, các tầng trên không cần quan tâm thiết bị được kết nối ra sau, mà chỉ quan tâm tầng dưới gửi dữ liệu gì để xử lý mà thôi.
* Ethernet có 1 kỹ thuật là CSMA/CD (Carrier-sense multiple access with collision detection) giúp nhận biết "collision domain" sóng mang xung đột. 
* CSMA/CD được dùng để quyết định khi nào kênh giao tiếp đang rãnh rỗi trên phân đoạn mạng (network segment) và khi nào 1 thiết bị đang rãnh để truyền dữ liệu.
&gt; Cách hoạt động khá đơn giản, khi có xung đột thì lập tức dừng truyền dữ liệu của các thiết bị gặp xung đột và chờ 1 khoảng thời gian ngẫu nhiên giúp tránh vụ va chạm (random interval trước khi thử gửi lại, và không đồng thời).

* Phân đoạn mạng của tất cả các thiết bị được kết nối sẽ có tất cả thông tin, dữ liệu đang trao đổi. Do đó, ta cần xác định thiết bị nào là nơi dữ liệu cần đến bằng MAC Address. 

### MAC Addresses (Media Access Control Address)

* Là địa chỉ để nhận diện toàn cầu được đính kèm với một network interface cá nhân.
* Giúp nhận dạng các máy tính khác nhau.
* Là một con số **48-bit** thường được biểu diễn bởi 6 nhóm với 2 con số hệ thập lục phân cho mỗi nhóm.
* Nghĩa là sẽ có tối đa 2^48 MAC address.
&gt; Hệ thập lục phân là cách biểu diễn các số sử dụng 16 ký tự. 
![](/assets/images/hexa.png)


* Octet: là 1 cách để tham chiếu số MAC. Trong mạng máy tính, bất kỳ số nào có thể biểu diễn bằng 8 bits được gọi là Octet.
=&gt; 2 chữ số thập lục phân có thể biểu diễn các số tương tự các số được biểu diễn bằng 8 bits.

* 03 Octets đầu tiên của địa chỉ MAC được gọi là OUI (Organizationally unique identifier), được gán cho nhà sản xuất phần cứng riêng lẻ.
=&gt; Từ 3 octets đầu có thể giúp ta xác định được NSX.
* 03 Octets sau được chỉ định theo ý nhà sản xuất mong muốn với điều kiện để mỗi thiết bị sản xuất ra có 1 MAC address duy nhất.
![](/assets/images/mac-1.png)

* Tóm lại, Ethernet protocol dùng MAC address để đảm bảo dữ liệu mà nó gửi có thông tin thiết bị nguồn và thiết bị đích gửi đến. Bằng cách này, dù ở trong một phân đoạn mạng hoạt động như thể có collision domain đơn lẻ, thì các thiết bị luôn biết được khi nào dữ liệu thuộc về nó. 

### Unicast, Multicast &amp; Broadcast frame
#### Unicast
Là sự truyền tải data đến 1 địa chỉ đích duy nhất.

Được nhận diện bằng cách nhìn vào bit ít quan trọng nhất trong octet đầu tiên của địa chỉ MAC đích trong Ethernet frame.

* Nếu là 0 : unicast
* Nếu là 1 : multicast
 
#### Multicast
Là sự truyền tải data đến nhiều địa chỉ MAC đích.

Các thiết bị mạng (network interface) có thể được cấu hình để chấp nhận 1 danh sách địa chỉ MAC được nhận data &amp; giao tiếp trong network cục bộ.

#### Broadcast
Ethernet broadcast address : FF:FF:FF:FF:FF:FF

Broadcast được sử dụng để tất cả các thiết bị có thể hiểu lẫn nhau.

Người gửi sẽ gửi tới tất cả các thiết bị trên mạng LAN.

### Ethernet Frame

* Data-packet: là 1 concept chung để chỉ 1 tập hợp dữ liệu nhị phân được gửi thông qua network link.

* Là 1 tập hợp (data-packet) các thông tin mang tính tổ chức cao, biểu diễn theo 1 thứ tự cụ thể.

* Bằng Ethernet frame, network interface có tại tầng 1 có thể chuyển đổi chuỗi bit qua một liên kết (data link) để cho ra 1 data có ý nghĩa (decode).

![](/assets/images/line-coding.png)

* Các phần trong frame là bắt buộc và có độ dài cố định.

![](/assets/images/ethernet-frame.png)


Thứ tự và các thành phần của Ethernet Frame gồm:

* Preamble (8 bytes): phần mở đầu, chia làm 7 bytes đệm + 1 byte SDF (dùng để làm dấu giới hạn khung bắt đầu, sau nó là khung dữ liệu thực tế).
Phần này được các network interface dùng để đồng bộ hóa các đồng hồ nội bộ mà chúng sử dụng nhằm điều chỉnh speed tại nơi mà chúng gởi dữ liệu.
* Destination MAC Address (48 bits/6 bytes): địa chỉ phần cứng đích, là bên nhận data.
* Source Address (6 bytes):  địa chỉ MAC nguồn.
* VLAN header (4 bytes): nếu trong khung có 4 bytes này thì nghĩa là đây là VLAN frame. Nếu có VLAN, thì sau nó phải có EtherType field. 
&gt; VLAN (Virtual LAN) là kỹ thuật cho phép ta có nhiều LAN hoạt động trên cùng 1 thiết bị vật lý (switch,..). VLAN được sử dụng để tách biệt traffic truy cập khác nhau với các thiết bị cùng mạng kết nối.

![](/assets/images/vlan.png)

* EtherType field (2 bytes): được dùng để diễn giải protocol (giao thức) của nội dung dữ liệu.

* Payload (từ 46-1500 bytes): là data chính cần được vận chuyển, chứa data tầng 3,4,5.

* FCS (4 bytes): viết tắt của Frame Check Sequence, là 1 con số có độ dài 32 bit, biểu diễn checksum value cho toàn bộ ethernet frame.

	* Checksum value: được tính bằng cách biểu diễn chu kỳ kiểm tra dự phòng (CRC) trên frame.

	* Cyclical redundancy check (CRC): là một khái niệm quan trọng đối với tính toàn vẹn dữ liệu (data integrity), và được dùng cho toàn bộ các tính toán học, không chỉ riêng truyền tải network. Đây là 1 phép toán học sử dụng phân chia đa thức để tạo ra 1 con số đại diện cho 1 tập dữ liệu lớn hơn và luôn kết thúc bằng 1 số checksum.

=&gt; Mục đích của checksum là để kiểm tra xem data bên đầu nhận có bị hỏng không.

Quy trình thực hiện:

* Thiết bị sẵn sàng lên frame để gửi đi
* Thiết bị bắt đầu thu thập đủ các thông tin cần có của 1 frame (trừ checksum)
* Thực hiện CRC trên các thông tin đó và gắn số checksum thu được.
* Đưa FCS vào frame hoàn chỉnh.
* Đưa frame vào một data link dùng protocol Ethernet
* Đầu thiết bị bên nhận thu thập các trường dữ liệu nhận được và tính toán lại checksum để so sánh với số checksum của frame gởi.
Nếu không khớp nhau, nó sẽ vứt ra ngoài vì trong quá trình truyền đã khiến data bị hỏng.
=&gt; Và nhiệm vụ của tầng trên sẽ quyết định xem data đó có nên được truyền lại hay không. 
=&gt; Kết luận: bản thân Ethernet chỉ báo cáo cho tầng trên biết về tính toàn vẹn của dữ liệu, chứ không có nhiệm vụ phục hồi dữ liệu.

Cụ thể hình ảnh cho quy trình:
![](/assets/images/CRC.png)
Sau đó đưa vào link và bên nhận nhận được, rồi bên nhận sẽ tính toán lại số checksum:
![](/assets/images/checksum.png)


## IV. Tầng 3 - Network
### IP Address

* Là một con số 32-bit được tạo thành từ 4 octet. Mỗi octet có độ dài 8-bit và biểu diễn dưới dạng số thập phân từ 0 đến 255.

Ví dụ: 12.34.56.78

* Các tổ chức lớn thường sử dụng IP address để xác định máy nào hơn là sử dụng MAC address để truyền tải dữ liệu trong mạng.
=&gt; IP có phân cấp rõ ràng và lưu trữ dữ liệu dễ dàng hơn.

&gt; Ví dụ công ty IBM có octet đầu được cấp riêng là 9. Thì khi router từ sender gửi dữ liệu thấy số 9 ở octet đầu của địa chỉ IP nhận (IP là 9.0.0.1 chẳng hạn), nó sẽ biết là cần gửi đến router của IBM, sau đó router của IBM sẽ tự xử lý phân phối dữ liệu đến các máy tính trong network của IBM thông qua các octet còn lại.

* Lưu ý: IP address thuộc về networks, chứ không thuộc về thiết bị được kết nối với các network.
&gt; Nghĩa là network (mạng) khác nhau sẽ có nhiệm vụ cấp phát IP khác nhau cho thiết bị của bạn bằng công nghệ DHCP khi bạn bật mạng của network đó.


* DHCP hay còn gọi là Dynamic IP Address (địa chỉ IP động) được dùng để cấp phát IP động cho các clients. 
* Static IP Address thì thường được dùng để cấp phát IP tĩnh cho server và các thiết bị mạng (router,...)

### IP Datagrams &amp; Encapsulation
#### IP Datagram
* Là data-packet (gói tin) ở tầng network theo giao thức IP.

* 2 phần chính của IP datagram là header và payload.
![](/assets/images/ip-datagram.png)

Ý nghĩa các trường trong datagram header:

* Version (4-bit): version của Internet protocol.
Ví dụ: IP version 4 thì Internet protocol là IPv4.

*  Header Length (4-bit): ghi số độ dài của header, thường là 20 bytes đối với IPv4. 20 byte cũng là độ dài tối thiểu của IP header.

* Service Type (8-bit): chi tiết về chất lượng dịch vụ, hoặc QoS, các công nghệ áp dụng.

* Total Length (16-bit): tổng chiều dài của IP datagram.
=&gt; Kích thước tối đa là con số lớn nhất có thể biểu diễn bằng 16 bits là 65,535.
=&gt; Nếu kích thước lớn hơn con số tối đa mà network hiện tại cho phép, IP layer sẽ chia làm các data-packet (gói tin/datagram) nhỏ hơn.

* Identification (16-bit): là số 16 bit được dùng để group các messages lại với nhau.
=&gt; Trường này giúp nhóm các gói tin bị tách ra lại với nhau thành 1 phần của đường truyền.

*  Flags (4-bit): chỉ ra rằng datagram này có được phép phân mảng hay không, hoặc đã được phân mảnh chưa. 

* Fragment Offset (12-bit): là quá trình phân mảnh datagram ra các datagram nhỏ hơn (nếu vượt quá giới hạn của network nó đang được truyền đến).

* Time to Live - TTL (8-bit): là trường chỉ ra bao nhiêu bước nhảy để 1 datagram có thể đi đến IP đích trước khi bị vứt đi. Đến số 0 thì router biết được là nó ko cần forward data nữa.
![](/assets/images/TTL.png)
Mục đích của bước này là để đảm bảo khi có cấu hình sai trong router gây ra vòng lặp vô tận như hình:
![](/assets/images/TTL-loop.png)

* Protocol (8-bit): thông tin về transport layer protocol được sử dụng ở gói tin này. (TCP, UDP,...)

* Header checksum (16-bit): số checksum nội dung của toàn bộ IP datagram header.
=&gt; Checksum phải được tính toán lại mỗi lần TTL chạm 1 bộ định tuyến (vì có IP thay đổi)

* Source &amp; Destination IP Address (32-bit) : địa chỉ IP nguồn và IP đích.

* Options: trường tùy chọn được dùng để thiết lặp các đặc tính đặc biệt cho datagram được dùng chủ yếu cho các mục đích testing. Trường này có độ dài biến đổi.

* Padding: thường dùng khi có trường Option. Là chuỗi số 0 để đảm bảo kích thước của header đúng kích thước tổng.


#### Encapsulation
Phần data payload section của Ethernet frame sẽ là toàn bộ IP datagram.

Quá trình gôm các data trong IP datagram lại với nhau thành frame gọi là encapsulation (tương tự payload của Ethernet frame).

* Toàn bộ data của IP datagram được đóng gói lại làm payload cho tầng ngay dưới nó (tầng 2), đó gọi là quá trình encapsulation. Các tầng khác cũng hoạt động như thế.

* Tầng sau đó sẽ dùng toàn bộ payload của tầng trước đó.

![](/assets/images/encapsulation.png)

### IP Address Classes

Là cách xác định cách địa chỉ global IP phân chia không gian.

* Class A: octet đầu là network ID, 3 octet sau là host ID.

* Class B: 2 octet đầu là network ID, 2 octet sau là host ID.

* Class C: 3 octet đầu là network ID, octet cuối là host ID.

![](/assets/images/ip-class.png)

### Address Resolution Protocol (ARP)

Là giao thức được dùng để khám phá địa chỉ MAC của một node với địa chỉ IP tương ứng.

Các thiết bị mạng sẽ lưu giữ 1 bảng ARP local chứa thông tin địa chỉ MAC ứng với IP của các thiết bị mạng đã từng kết nối (trong 1 khoảng thời gian nhất định).

Thiết bị truyền sẽ tìm đến địa chỉ đích bằng cách phát tín hiệu ``broadcast`` FF:FF:FF:FF:FF:FF cho tất cả các máy tính trong mạng local rằng tôi muốn tìm địa chỉ MAC của máy có địa chỉ IP này.

Máy có địa chỉ IP đó sẽ lên tiếng và gửi ARP response chứa địa chỉ MAC lại cho sender (thiết bị truyền).

Giờ thì thiết bị truyền có thể đưa MAC address vào Ethernet frame để truyền tải dữ liệu.

### Subnetting 

Là quá trình tách network lớn thành nhiều network nhỏ hơn gọi là các subnetworks hoặc subnets.

![](/assets/images/subnetting.png)

#### Subnet Mask

* IP: 9.100.100.100

* Subnet mask: 255.255.255.224

* Subnet mask in binary: 11111111 11111111 11111111 11100000

=&gt; 9.100.100.100/27
&gt; Có 27 số 1 (các số 1 này là subnet ID).


![](/assets/images/subnet-id.png)
Hình trên là ví dụ của subnet mask: 255.255.255.0


Subnet mask là cách để máy tính sử dụng toán tử AND để xác định địa chỉ IP đó có tồn tại trên cùng network hay không.


#### CIDR (/ notation)
Là một cách tiếp cận linh hoạt để cung cấp số lượng địa chỉ IP phù hợp với nhu cầu. CIDR cho phép network tự phân chia kích thước.
![](/assets/images/subnet-2.png)

Nó dựa vào subnet để Demarcate (phân định).

Demarcation point là cách để mô tả nơi 1 network hay system kết thúc và cái khác bắt đầu.

Một IP thường có Network ID, Subnet ID, Host ID.
Tuy nhiên với CIDR, Network ID và Subnet ID thường được kết hợp làm một. 

&gt; Nếu công ty cần nhiều hơn 1 class C số lượng địa chỉ IP max mà class C có thể cung cấp (254). Thay vì tạo 2 class C để gấp đôi thì giờ đây với CIDR, nó chỉ cần kết tnoosi không gian địa chỉ liên tục với nhau với mask /23 hay có thể nói là 255.255.254.0.

Giờ đây router chỉ cần biết 1 entry trong routing table để vận chuyển lưu lượng đến các địa chỉ đích thay vì 2.

&gt; Trước đây network ID là tĩnh và chỉ có class A,B,C để phân định kích thước cố định và chỉ có subnet mới có thể thay đổi. Với CIDR thì mọi chuyện đã khác.

![](/assets/images/CIDR-23.png)

Phân tích hình trên 1 chút:

* Hãy nhớ là ta sẽ luôn mất 2 host ID trên mỗi mạng. (giá trị đầu và cuối trong range) 

* Nếu không dùng CIDR, ta cần 2 network class C nên = 254+254
IDR
* /23 nghĩa là thêm được 1 bit cho Host ID = 2^9


### Routing (lộ trình) 
#### Concept

* Định nghĩa Router: Là thiết bị mạng chuyển tiếp traffic phụ thuộc vào địa chỉ đích của traffic đó.
Router thường có 2 network interface giúp nó có thể vận chuyển traffic giữa 2 network với nhau.

![](/assets/images/routing.png)

Lộ trình ở hình trên sẽ được lặp lại cho đến khi traffic đến được địa chỉ đích.

![](/assets/images/routing-2.png)

Diễn giải hình trên như sau:

* Máy tính có IP 192.168.1.100 (máy A) muốn gửi gói tin đến máy có IP 10.0.0.10 (máy B)
* Máy A nằm trong Network A và biết rằng máy B không nằm trong local Network A.
* Máy A gửi gói tin này đến địa chỉ MAC của gateway của nó là Router A có IP gateway là 192.168.1.1.
* Router interface trên Network A nhận được gói tin vì nó thấy địa chỉ MAC đích trên Ethernet frame thuộc về nó. Sau đó, nó bỏ đi phần header của tầng Data-link để đưa đến tầng 3 phân tích tiếp.
* Router sẽ trực tiếp kiểm tra header của IP datagram ở tầng 3. Nó tìm thấy IP đích chính là 10.0.0.10 thuộc về mạng B (10.0.0.0/24) trong Routing Table.
Mạng B có interface kết nối với router này.
* Tiếp theo Router sẽ tạo 1 gói tin mới để gửi cho Network B bằng cách sao chép dữ liệu IP datagram nhưng giảm trường TTL xuống 1 đơn vị + tính toán giá trị checksum mới.
* Sau đó đóng gói IP datagram mới này bên trong 1 Ethernet frame mới với địa chỉ MAC đích là địa chỉ MAC của IP 10.0.0.10 của network B mà nó lưu sẵn trong ARP table.
* Và cuối cùng gói tin sẽ được gửi ra khỏi interface của router trên Network B để đến với máy B.

![](/assets/images/routing-3.png)

* Máy A muốn gửi đến máy C phải thông qua router interface của máy A trên Network B và router interface của máy C trên Network B.
* Cụ thể là máy A sau khi thấy IP đích không thuộc local network thì sẽ gửi đến gateway của nó là Router A thì router A này kiểm tra trong routing table thấy cách nhanh nhất là gửi gói tin đến router B để đến với máy C.
* Sau đó router A sẽ -1 bước nhảy cho trường TTL và gửi cho router B thông qua router interface của router A trên network B và router interface của router B trên network B.
* Do network của máy C được kết nối trực tiếp với router B thông qua router interface thuứ 2 của router B. Nên router B sẽ gửi thẳng gói tin đến máy C trên Network C và kết thúc lộ trình. 

#### Routing table
* Cơ bản nhất sẽ có 4 cột. Trong đó có cột Network. Các cột còn lại có thể là IP, Subnet Mask hay CIDR. 
* Sẽ có từng hàng cho từng Network mà router này biết.
* Khi nhận được gói tin, router sẽ biết IP đích đó thuộc network nào dựa vào routing table của nó.
* Routing table sẽ luôn có 1 mục chung (catchall entry) cho bất kỳ địa chỉ IP nào không có network rõ ràng.

* Next hop: là địa chỉ IP của router tiếp theo sẽ nhận dữ liệu
* Total hops: tổng số bước nhảy còn lại được tính toán đường đi ngắn nhất (sử dụng thuật toán) để đưa gói tin đến đích.

* Các routing table sẽ luôn được update thông tin mới về đường dẫn nhanh nhất đến mạng đích. 

#### Gateway Protocol 
Router sử dụng Routing Protocol để nói chuyện với các Router khác để chia sẻ thông tin với nhau, tìm ra con đường ngắn nhất để chia sẻ gói tin,...

Routing protocol có 2 loại : 
* Interior Gateway Protocol
* Exterior Gateway Protocol

##### Interior Gateway Protocol
Được router sử dụng để chia sẻ thông tin trong 1 hệ thống autonomous đơn (1 tổ chức điều hành mạng).

Autonomous system là tập hợp các Network dưới sự quản lý của 1 nhà điều hành mạng duy nhất. 
&gt; Ví dụ như 1 tập đoàn cần routing traffic mạng của họ giữa các office của họ và mỗi office có thể có 1 local network. Hoặc ví dụ khác là 1 tổ chức nhà mạng lớn của quốc gia quản lý các router thuộc nhà mạng đó.

![](/assets/images/interior-protocol.png)

Interior Gateway Protocol bao gồm 2 loại:

* Distance-vector protocol (tiêu chuẩn cũ)
Router dựa vào danh sách khoảng cách giữa các network trong routing table của router dưới dạng bao nhiêu hops, sau đó gửi danh sách này cho các router lân cận bằng Distance-vector protocol. Do đó các router lân cận có thể đoán được đường đi nào nhanh hơn.
=&gt; Router sẽ được cập nhật routing table thường xuyên.
![](/assets/images/distance-protocol.png)

* Link state routing protocol
![](/assets/images/link-state.png)
Giao thức này có cách tiếp cận tinh vi hơn. Từng router trong autonomous system sẽ broadcast thông tin của nó đến tất cả các router còn lại, và chúng sẽ có hết thông tin của nhau.
Các router sẽ chạy các thuật toán phức tạp để tìm đường đi ngắn nhất đến địa chỉ đích.
Do vậy cần bộ nhớ nhiều hơn và bộ xử lý tốn kém hơn. 

&gt; Khi phần cứng trở nên mạnh mẽ hơn đã khiến giao thức vector trước đó trở nên cũ và lạc hậu.

##### Exterior Gateway Protocol
Được sử dụng bởi các Edge router của tổ chức cần chia sẻ thông tin với các tổ chức điều hành mạng khác.
&gt; Đây là chìa khóa chính của Internet vì Internet là mạng lưới khổng lồ của các autonomous system.

Ở mức cao nhất sẽ có một Core internet router nắm giữ thông tin của các autonomous system. Nhiệm vụ chính của nó là đưa dữ liệu vào Edge Router của các autonomous system.

![](/assets/images/core-router.png)


* Internet Assigned Numbers Authority (IANA) : Là 1 tổ chức giúp quản lý những thứ như phân bổ IP address, ASN,...

* ASN (Autonomous System Number): Là con số thập phân 32-bit định danh cho mỗi autonomous system. ASN không cần phải thay đổi để đại diện cho mỗi autonomous system. 
ASN chỉ thường được dùng bởi các core Internet router và được cập nhật thường xuyên trong routing table để biết mà điều phối traffic.

* Người ta thường nhìn vào ASN để biết autonomous system thuộc về nhà quản trị mạng nào. Ví dụ AS19604 = IBM.

##### Non-routable Address Space 
Cho phép các thiết bị mạng giao tiếp với nhau mà không cần thông qua gateway router. 

* Network address translation (NAT): là loại công nghệ cho phép các không gian địa chỉ mạng không được định tuyến giao tiếp với các thiết bị khác trên internet.

RFC 1918 (Request for comments) đã định nghĩa 3 dải IP không bao giờ được định tuyến trên Internet bên ngoài, mà chỉ có thể được định tuyến bởi các giao thức interior gateway protocol trong local network. Do vậy bất cứ ai cũng có thể sử dụng những IP này cho mạng nội bộ của họ.

![](/assets/images/rfc-1918.png)

## V. Tầng 4 - Transport Layer

Socket number hay còn gọi là Socket port: 10.1.1.23:80

* Nếu muốn request HTTP web page trên con server đang listen IP 10.1.1.23 thì traffic sẽ được direct đến port 80 của con server với IP đó.

* FTP (File transfer protocol) là giao thức cũ dùng để transfer file từ máy này sang máy khác, dùng port 21.


![](/assets/images/layer4.png)

### TCP Segment

Là gói tin bao gồm phần TCP header và payload (data section). Và gói tin này là payload của IP datagram.

![](/assets/images/tcp-header.png)

TCP header gồm 1 số phần quan trọng:
* Sequence number (32-bit): số dùng để xác định vị trí của gói tin trong sequence gồm các TCP segment.
&gt; Do tầng 3 có giới hạn size là 1,518 bytes nên cần phải tách các gói tin ra, TCP chia data thành nhiều segment để gửi cho tầng 3. Vậy nên số này dùng để xác định segment hiện tại là segment nào trong sequence của 1 gói tin lớn đã được tách ra.
* Acknowledgment number (32-bit): là số tiếp theo sau sequence number.
* Checksum: Khi gói tin đã nhận được ở đầu nhận, nó sẽ được tính toán checksum lại để so sánh với checksum ở header này.
* Urgent pointer field: gắn liền với TCP control flag để chỉ ra segment nào quan trọng hơn các segment còn lại trong sequence.

### Control Flags
Là 1 số 6 bit, mặc định 000000 theo thứ tự như bên dưới:

* URG (Urgent): nếu bit này là 1, chỉ rằng segment này là khẩn cấp và trường Urgent pointer field sẽ có nhiều thông tin hơn để lý giải cho flag này.
* ACK (acknowledge): nếu là 1 nghĩa là cần kiểm tra trường acknowledge number trong TCP header
* PSH (push): thiết bị gửi mong muốn thiết bị nhận push các data trong bộ nhớ đệm đến ứng dụng ở phía đầu cuối (vd web browser) càng sớm càng tốt. 
* RST (reset): 1 phía kết nối TCP chưa thể khôi phục lại hoàn toàn sau khi trải qua các segment bị mất thông tin hoặc gặp sự cố.
&gt; Đây là cách mà các TCP khác trong sequence thông báo là "Từ từ tôi chưa thể tổng hợp thông tin từ bạn được"
* SYN (synchronize): gửi tín hiệu yêu cầu động bộ, được sử dụng cho lần đầu thiết lập TCP connection và đảm bảo đầu cuối biết để kiểm tra sequence number field.
* FIN (finish): khi được set là 1 nghĩa là bên máy tính gửi không còn data nào để gửi và kết nối có thể được đóng lại.

### TCP connection
#### The three-way handshake 
Sau khi three-way handshake hoàn tất, TCP connection sẽ được thiết lập.
&gt; Handshake là cách để 2 thiết bị đảm bảo là nó đang nói chuyện trên cùng 1 protocol và có thể hiểu nhau.

![](/assets/images/3way-handshake.png)

Giải thích:
* Máy A gửi gói tin TCP segment gắn cờ SYN cho máy B.
* Máy B phản hồi " Hãy thiết lập kết nối, tôi biết sequence num của bạn rồi".
* Máy A phản hồi "Tôi nhận tin, hãy bắt đầu gửi data thôi".


![](/assets/images/2side-tcp.png)

* Cả 2 máy đã được thiết lập TCP connection sẽ vận hành 2 chiều với nhau vì đã pair cùng nhau. Gói tin gửi theo chiều nào cũng được phản hồi =&gt; phía còn lại luôn biết đã nhận được gì.

#### The four-way handshake 
Khi mà 1 trong các máy tính sẵn sàng ngắt kết nối thì nó sẽ gửi cờ FIN, máy tính nhận được sẽ gửi ACK. Nếu máy gửi ACK sẵn sàng ngắt thì cũng gửi nốt cờ FIN. Sau đó máy đòi ngắt sẽ gửi lại cờ ACK "ok tôi ngắt đây".

![](/assets/images/4way-handshake.png)

### TCP Socket

#### Định nghĩa:
* Socket là khởi tạo (instantiation) của 1 end-point trong kết nối TCP tiềm năng.
* Instantiation là việc triển khai thực tế ở 1 thứ gì đó được định nghĩa ở đâu đó.

=&gt; TCP Socket cần có các chương trình thực để khởi tạo nó. 
=&gt; Bạn có thể gửi dữ liệu đến bất cứ port nào, nhưng bạn chỉ nhận được phản hồi từ server nếu chương trình mở socket ở port đó. 

Các trạng thái của TCP:

* LISTEN : TCP socket đã sẵn sàng và chờ đợi các kết nối vào. (chỉ thấy trạng thái này ở server-side)

* SYN_SENT: có 1 request đồng bộ đã được gửi đi nhưng kết nối chưa được tạo. (chỉ thấy trạng thái này ở client-side)

* SYN-RECEIVED: 1 socket trước đó trong trạng thái LISTEN đã nhận được yêu cầu đồng bộ và đã gửi lại tín hiệu SYN/ACK cho client.

* ESTABLISHED: kết nối TCP đang hoạt động và cả 2 phía đều thoải mái gửi dữ liệu cho nhau. (trạng thái đều có ở cả client và server).

* FIN_WAIT: 1 tín hiệu FIN đã được gửi đi nhưng chưa nhận được ACK từ phía còn lại.

* CLOSE_WAIT: kết nối đã được đóng tại tầng TCP nhưng ứng dụng dùng để mở socket này chưa release socket này.

* CLOSED: kết nối đã chấm dứt và không còn giao tiếp với nhau được nữa.

Ngoài ra còn có các trạng thái TCP khác. Thực tế trạng thái TCP còn phụ thuộc vào hệ điều hành vì nằm ngoài phạm vi của TCP. 

### Connection-oriented protocol (vd TCP)

Là giao thức thiết lập kết nối, sử dụng nó để đảm bảo tất cả các data được gửi đúng. Đảm bảo tất cả segment đều được ACK.

TCP là loại này. TCP sẽ mong đợi từng ACK cho mỗi bit dữ liệu để đảm bảo data truyền tải chính xác và dựa vào sequence number để đưa các gói tin vào đúng thứ tự.

Tầng Transport có protocol này là tầng sẽ quyết định data có cần phải gửi lại không. Còn các tầng 1,2 thì chỉ kiểm tra và vứt gói tin nếu không thỏa checksum.

![](/assets/images/tcp-flow.png)

Do vậy, giao thức này sẽ tốn nhiều chi phí cho việc:
* Tạo connection
* Gửi liên tục các luồng ACK
* Phá vỡ kết nối
=&gt; Chỉ hữu ích khi bạn hoàn toàn muốn dữ liệu được truyền tải chính xác.

### Connectionless protocol (vd UDP - User Datagram protocol)

UDP không phụ thuộc vào connection và cũng không hỗ trợ khái niệm ACK.

Với UDP bạn chỉ cần thiết lập 1 cổng port rồi gửi gói tin đi là được. Điều này hữu ích với các message không quá quan trọng như streaming video.
=&gt; Bằng việc loại bỏ chi phí khi sử dụng TCP, ta có thể tối ưu bằng cách tăng chất lượng video với UDP (giúp tiết kiệm băng thông để dành cho việc truyền data chất lượng cao thay vì dành cho việc thiết lập các kết nối TCP).


### Firewall 

Là thiết bị giúp ngăn chặn traffic truy cập thỏa tiêu chí nhất định để đảm bảo security.

Firewall có thể hoạt động ở nhiều tầng lớp khác nhau, nhưng phổ biến nhất là ở tầng 4 - Transport.
Ví dụ như chặn truy cập đến 1 số port nhất định trong khi cho phép traffic đến các port khác. 

![](/assets/images/firewall.png)

Như hình trên, firewall được đặt trước server để chặn truy cập bên ngoài vào port 445 (phục vụ service quản trị file nội bộ), và cho phép port 80 mở (phục vụ website của công ty) để bên ngoài mạng LAN có thể truy cập vào.

Firewall đôi khi là thiết bị mạng độc lập, hoặc có thể xem nó là 1 chương trình có thể chạy ở bất cứ đâu, nó có thể tích hợp chung với router. Ngoài ra nó có thể chạy trên server cá nhân thay vì là 1 network device, các hệ điều hành lớn hiện nay đều được tích hợp sẵn firewall.  



## VI. Tầng 5 - Application layer 

### Mô hình OSI (Open Systems Intersection) 

![](/assets/images/OSI.png)

* Session Layer: Tạo điều kiện giao tiếp giữa các actual application với tầng transport. Nó là 1 phần của hệ điều hành OS đã được un-encapsulation để lấy "payload" của application từ các tầng dưới và chuyển lên tầng Presention.

* Presentation layer: có nhiệm vụ đảm bảo việc unencapsulation dữ liệu của tầng application layer có thể được hiểu bởi ứng dụng đang yêu cầu nhận dữ liệu.
Đây là 1 phần của OS giúp xử lý mã hóa encryption hoặc nén dữ liệu. 

=&gt; Nhận thấy 3 tầng cuối không còn cơ chế encapsulate dữ liệu nữa nên được gộp lại thành mô hình 5 tầng và được xem là hiệu quả nhất. Tuy nhiên, việc hiểu rõ cơ chế hoạt động và mô hình nguyên thủy sẽ giúp ta có kiến thức cơ bản để hiểu về network tốt nhất.


Dưới đây là mô phỏng quy trình network truyền tải dữ liệu từ máy 1 đến máy 2:

![](/assets/images/all-layers.png)

Máy 1 sẽ truyền data payload kèm sign SYN/ACK và máy 2 trả về SYN/ACK cứ thế cho đến khi cả 2 hoàn thành nhiệm vụ gửi nhận dữ liệu. 


-------------------------------
#### DNS
Địa chỉ IP là 1 số binary 32-bit nhưng được viết dưới dạng thập phân để dễ đọc hơn.

Vì não người nhớ số không tốt nên DNS ra đời để giúp giải quyết vấn đề truy cập địa chỉ IP dễ dàng hơn, con người chỉ cần nhớ domain bằng chữ.

* DNS là dịch vụ mạng toàn cầu giúp giải mã chữ thành địa chỉ IP cho bạn.

* Domain name là thuật ngữ ta dùng để chỉ những gì DNS có thể xử lý.

Địa chỉ IP ứng với tên miền có thể thay đổi vì nhiều lý do như thay đổi hợp đồng, trụ sở data center. Bằng cách sử dụng DNS, quản trị viên có thể thay đổi IP ứng với tên miền, lúc này end user thậm chí sẽ không bao giờ biết là IP đã thay đổi.

=&gt; Lợi ích của DNS:

* Giúp dễ nhớ đường dẫn trang web thông qua Domain name hơn
* Cho phép thay đổi quản trị ngầm mà không cần end user thay đổi hành vi.
* DNS cho phép đối ứng domain name theo vùng. Ở vùng A thì có địa chỉ IP x ở vùng B thì địa chỉ y. Giúp lưu lượng truy cập máy chủ ở gần khu vực khi mà công ty bạn muốn đặt data center ở vùng nào đó để truyền dữ liệu gần nhau nhanh hơn.

![](/assets/images/dns.png)
  

Để cấu hình 1 mạng tiêu chuẩn, có 4 thứ cần cấu hình để host vận hành trong mạng như mong muốn:
* IP address
* Subnet mask
* Gateway for a host
* DNS server

Có 5 loại DNS server:
![](/assets/images/dns-server.png)

* Caching and recursive name servers:
Mục đích để lưu các tra cứu domain name trong 1 khoảng thời gian nhất định. Loại này thường được ISP hoặc local network cấp phát.
Hầu hết các caching name server thường là recursive name server.

* Recursive name servers: thực thi đầy đủ yêu cầu đối ứng tra cứu toàn bộ (full resolution) DNS.

Hầu hết các local name server sẽ thực hiện nghĩa vụ của cả 2 loại, nhưng hoàn toàn có thể có trường hợp name server làm 1 trong 2 nhiệm vụ caching hoặc recursive thôi. 


![](/assets/images/name-server.png)

Khi Friend yêu cầu local name server cung cấp IP của fb.com thì recursive server sẽ thực thi full resolution tra cứu toàn bộ trên máy chủ dịch vụ DNS để trả về IP. Sau đó IP này sẽ được lưu trữ trong cache với trong khoảng thời gian TTL nhất định.

Vài phút sau nếu You truy cập cùng fb.com thì local name server sẽ trả về máy tính của You địa chỉ IP tương tự mà không cần tra cứu toàn bộ.

* TTL (Time to live): là giá trị bằng giây có thể được cấu hình bởi chủ của tên miền, là thời gian mà name server cho phép cache trước khi nó bị hủy và thực thi tra cứu lại DNS (full resolution).


##### Full recursive resolution:

![](/assets/images/full-resolution.png)

Name server đã cấu hình sẽ thực hiện tra cứu toàn bộ DNS theo quy trình sau:

* B1: liên hệ với root name server. Chúng chịu trách nhiệm điều hướng truy vấn tên miền đến TLD server thích hợp.

Ngày nay chúng thường phân bố trên toàn thế giới thông qua ``anycast``. Đây là 1 kỹ thuật được sử dụng để điều hướng truy cập đến các destination khác nhau dựa trên yếu tố địa lý, tắc nghẽn (congestion) hoặc link health.  13 root name servers được xem như 13 object được cấp quyền để cung cấp dịch vụ tra cứu tên router.

Root server sẽ trả về địa chỉ của TLD name server (Top Level Domain), trong ví dụ là ``.com``. 
![](/assets/images/TLD.png)

* B2: TLD name server sẽ tra cứu máy chủ nào được cấp quyền cho trang web ví dụ domain ``weather.com``, đó là 1 tổ chức chạy trang web này. 

* B3: Sau đó tra cứu DNS sẽ tiếp tục được điều hướng đến máy chủ được cấp quyền domain name ``weather.com``, nơi sẽ cho ra IP thật của server cần truy vấn/cần request data. 


#### DNS over Protocol (TCP, UDP)
##### TCP
Thường không dùng TCP, chỉ dùng khi gói tin lớn. Khi gói tin quá lớn UDP không chứa được hết thì DNS server sẽ phản hồi quá lớn. Lúc này DNS Client sẽ thiết lập TCP connection để tra cứu.

![](/assets/images/tcp-dns.png)


##### UDP
Không cần tạo các kết nối như TCP. 
![](/assets/images/udp-dns.png)

UDP không có cơ chế khôi phục lỗi. Nhưng đơn giản nếu khi phát sinh lỗi, DNS chỉ cần request lại nếu không nhận được phản hồi, không cần phải khôi phục.


##### Resource Record Type 

DNS hoạt động dựa trên 1 tập hợp các record. Có nhiều loại record phục vụ các mục đích khác nhau:

* ``A record``: được dùng để trỏ 1 tên miền đến 1 địa chỉ IPv4 nhất định.
Cơ bản thì 1 domain name sẽ trỏ đến 1 bản ghi chứa địa chỉ IPv4, nhưng thực ra 1 domain cũng có thể trỏ đến nhiều bản ghi A.
=&gt; Kỹ thuật ``DNS Round Robin``được sử dụng để cân bằng lưu lượng truy cập trên nhiều IP. 

Ví dụ www.microsoft.com có thể cấu hình 4 A records ứng với 4 name servers có thẩm quyền cho tên miền này. Sau đó từng lượt truy cập sẽ được điều hướng đến IP của name server lần lượt theo cơ chế round robin (thay đổi thứ tự đầu tiên) giúp giảm traffic. Máy tính phân giải DNS biết cả 4 record nhưng nó chỉ dùng record thứ tự đầu tiên, trường hợp kết nối thất bại nó sẽ kết nối tới record tiếp theo.

* ``AAAA-Quad A``: tương tự A record nhưng trả về địa chỉ IPv6 thay vì IPv4.

* ``CNAME record``: được sử dụng để chuyển hướng traffic từ 1 domain sang 1 domain khác.
Vd: nếu bấm microsoft.com thì CNAME được cấu hình trước đó sẽ phân giải thành www.microsoft.com và DNS server sẽ phân giải tiếp ra IP của www.microsoft.com

CNAME còn giúp thay đổi địa chỉ IP của 1 máy chủ ở 1 nơi thôi.

=&gt; Có 2 cách để khi bấm microsoft.com và www.microsoft.com đều đến cùng 1 nơi:

	* C1: Thiết lập record tương tự nhau cho cả 2 domain. Nếu thay đổi IP thì phải thay đổi cho cả 2 nơi của record.
	* C2: Setup CNAME trỏ microsoft.com đến www.microsoft.com, khi cần thay đổi IP chỉ cần thay đổi domain chính www.microsoft.com.

* ``MX record - mail exchange``: đảm bảo traffic thư từ sẽ được gửi đến mail server của công ty.

* ``SRV record``: giống MX nhưng khác chỗ là nó có thể trả về các record dịch vụ khác nhau như calendar.

* ``TXT record``: giúp ta có thể chèn các note vào trong message gửi đi hoặc cấu hình network. TXT record thường được sử dụng để truyền tải thông tin bổ sung đến email dưới dạng NCC dịch vụ ví dụ "Mail Delivery Failure",...

* Ngoài ra còn các bản ghi NS hoặc SOA được sử dụng để xác định thông tin thẩm quyền về các DNS Zone.


#### Anatomy of a Domain name

* ICANN là tổ chức tiền thân của IANA, cả hai cùng phối hợp để quản lý việc cấp phát và điều phối IP + DNS + TLD của Internet toàn cầu.

</code></pre>
<p>www.google.com</p>
<pre><code>Trong đó chia làm các vùng sau:

* ``.com``: phần TLD
* ``google``: phần Domain 
* ``www``: phần sub-domain 
=&gt; Tất cả là Fully qulified Domain name (FQDN)

Registrar là các công ty có thỏa thuận với ICANN để cấp phát/bán domain name chưa đăng ký cho bất kỳ ai.

* Mỗi vùng domain phải &lt;=63 ký tự.
* FQDN thì tối đa 255 ký tự.
* DNS support tối đa 127 level domain trong 1 FQDN.


##### DNS Zones
Ra đời để cho phép kiểm sóat nhiều level của domain name một cách dễ dàng hơn.

![](/assets/images/dns-zone.png)

Như hình ta sẽ có 4 cấu hình DNS server sẽ được thiết lập. 1 cho domain chính và 3 cái còn lại cho subdomains.

Chúng sẽ được cấu hình thông qua ``Zone files``.

* ``Zone files`` là những tệp tin cấu hình đơn giản khai báo tất cả các record của 1 zone nào đó.
Zone file phải bao gồm SOA (Start of Authority).
* SOA sẽ khai báo zone và tên của name server được cấp quyền để khai báo zone.
* NS record cũng có thể xuất hiện trong file để khai báo những name server khác có thể chịu trách nhiệm cho zone này.
* Ngoài ra cũng có thể xuất hiện các record A, AAAA, CNAME trong zone file.

Ngoài việc tra cứu từ domain sang IP trong record. Ta còn sẽ bắt gặp kỹ thuật Resolve lookup zone file cho phép DNS server yêu cầu IP và trả về FQDN cùng với nó, dùng PTR record.

* ``PTR`` (Pointer resource record) : phân giải IP thành name 



### DHCP

Để cấu hình 1 mạng tiêu chuẩn cần có IP address, Subnet mask, Gateway, Name server.

Trong đó chỉ có IP là cái khác nhau cho mỗi node, còn lại thì hầu như cố định cho các node trong 1 mạng.

=&gt; DHCP ra đời để giúp cấu hình network cho OS máy bạn, giúp phân bổ IP

* DHCP là protocol ở tầng application giúp tự động hóa việc cấu hình mạng cho các host trong network.
Một node trong mạng sẽ truy cập DHCP server để truy vấn IP và sẽ nhận được toàn bộ cấu hình chuẩn gồm 4 cái trên.

Các máy client được assign bất kỳ trong 1 dải quy định.
Các thiết bị khác như router hay DNS server,... cần IP tĩnh để dễ diagnose khi gặp sự cố.

#### DHCP discovery 
Là quá trình client cấu hình sử dụng DHCP để có được thông tin cấu hình network.

#### Quy trình DHCP cấp phát IP 
* Client gửi thông báo broadcast tìm kiếm DHCP (gọi là DHCP discover message)
![](/assets/images/DHCPdiscover.png)
* DHCP server sẽ kiểm tra cấu hình của client để quyết định IP nào sẽ cấp. Tùy thuộc vào static hay dynamic hay fixed.
* DHCP server sẽ phản hồi broadcast bằng DHCPOFFER message và trong msg có địa chỉ MAC của destination address.
![](/assets/images/DHCPoffer.png)
* Client có thể từ chối cấp phát IP từ 1 máy chủ DHCP bất kỳ trong mạng. Client sẽ phản hồi broadcast bằng DHCPREQUEST nói rằng ok đến DHCP server. Vì chưa có IP nên client sẽ mặc định gửi từ 0.0.0.0.

![](/assets/images/DHCPrequest.png)
* Sau đó DHCP server sẽ phản hồi broadcastr xác nhận bằng DHCPACK.
![](/assets/images/DHCPack.png)

* Client nhận message và bắt đầu thiết lập cấu hình network cho OS máy tính theo message nhận được.

#### DHCP lease 
Là hạn thời gian được sử dụng cấu hình cấp bởi DHCP. Hết thời gian này thì client phải thực hiện lại quy trình trên.

Ngoài ra, client cũng có thể setup thời gian lease của nó để ngắt kết nối network đến DHCP server thông qua cách tắt mạng tự động. Điều này sẽ trả địa chỉ IP của client về danh sách IP có thể cấp phát của DHCP.

### NAT (Network Address Translation)
Là kỹ thuật cho phép gateway thường là router hay firewall rewrite IP source của 1 IP datagram đi ra network ngoài trong khi vẫn lưu giữ lại IP ban đầu để rewrite lại sau khi nhận được response từ các service ở network ngoài.

Router thông thường chỉ nhận IP diagram kiểm tra trừ TTL 1 đơn vị, tính lại checksum.
Khi có NAT thì nó sẽ rewrite lại IP.

![](/assets/images/NAT.png)

IP soure từ máy 1 khi hiển thị với máy 2 sẽ là IP gateway của router ở máy 2. 

&gt; NAT sẽ giúp bảo vệ, ẩn IP của máy 1 khi gói tin đến với máy 2 và sẽ viết lại IP chính xác của máy 1 khi router nhận được response từ máy 2.

Về mặt security, không ai có thể thiết lập kết nối với máy tính của bạn nếu họ không biết địa chỉ IP. Đây gọi là ``IP masquerading`` (giả mạo IP) và là khái niệm bảo mật quan trọng. 

#### NAT và Transport layer
##### Port preservation
Là kỹ thuật mà source port được chọn bởi máy client sẽ giống với port dùng bởi router.
![](/assets/images/port-preservation.png)

Outbound connection chọn ngẫu nhiên 1 ephomeny source port hoặc trong dải 49152 đến 65535.

Lúc này router NAT chỉ cần lưu lại source port để trả response về đúng máy tính đã gửi msg đi.

##### Port forwarding
Là kỹ thuật mà destination port cụ thể có thể được cấu hình để luôn được chuyển đến node cụ thể nào đó.
 
![](/assets/images/port-forwarding.png)

Ví dụ trong network công ty có nhiều node (server) làm nhiều nhiệm vụ/service khác nhau. Các máy tính bên ngoài không cần biết IP của các service này là gì mà chỉ cần IP gateway của router kết nối đến network đó + destination port của service.

Với port forwarding, traffic của 2 service có thể trả về cho cùng 1 IP mạng ngoài (gateway) và sẽ có cùng DNS name. Nhưng ngược lại, response có thể được trả về đến những internal server khác nhau nhờ các destination port khác nhau.

&gt; Kỹ thuật này giúp giả mạo IP (IP masquerading) và giúp người dùng bên ngoài tương tác với nhiều dịch vụ chạy trong cùng 1 tổ chức.

##### NAT và Non-Routable Address Space
Kể từ khi IANA đảm nhận phân bổ IP trên toàn cầu với số lượng có sẵn là 4,2 tỷ IPV4 thì đến khoảng từ năm 2010, các RIRs bắt đầu cạn kiệt IPv4.

*RIRs là 5 lãnh thổ được IANA phân chia quản trị IPv4.
    AFRINIC, which serves the continent of Africa

    ARIN, which serves the United States, Canada and parts of the Caribbean

    APNIC, which is responsible for most of Asia, Australia and New Zealand and Pacific Island nations

    LACNIC, which covers Central and South America and any parts of the Caribbean not covered by ARIN

    RIPE, which serves Europe, Russia,the Middle East, and portions of Central Asia
    

&gt; IPv6 sẽ giúp giải quyết vấn đề cạn kiệt IPv4, tuy nhiên để biến IPv6 phổ biến toàn cầu cần có thêm thời gian.


Trong thời gian này, chúng ta sẽ dùng NAT và Non-Routable Address Space làm giải pháp tạm thời.
Điều này sẽ giúp cho hàng ngàn máy tính chỉ cần dùng 1 public IPv4 là IP gateway của router thông qua kỹ thuật NAT ở trên, giúp gửi nhận msg bình thường qua internet.

![](/assets/images/limitIPv4.png)

Cho đến khi IPv6 được sử dụng phổ biến, ta phải dùng kỹ thuật này để giải quyết tạm thời vấn đề cạn kiệt IPv4.

Tham khảo thêm tại: https://en.wikipedia.org/wiki/IPv4_address_exhaustion

### VPN &amp; Proxies
#### Virtual Private Network
* Là công nghệ giúp mở rộng private hoặc local network ra các host mà không nằm trong network đó.
* Là tunelling protocol. Thiết lập VPN connection là thiết lập VPN tunnel.
![](/assets/images/vpn.png)
&gt; Phổ biến nhất là dùng cho nhân viên truy cập vào mạng công ty để xem/sử dụng resource tại nhà.

Quy trình:

* Nhân viên sử dụng VPN client để thiết lập tunnel đến mạng công ty. Nó giúp tạo 1 interface ảo để được cấp phát IP trong mạng công ty.
* Lúc này client sẽ được cấp 1 IP trong mạng công ty.
* Vậy là từ lúc này client có thể access resource của công ty bằng cách gửi message đi thông qua IP interface ảo này như thể đang kết nối mạng private của công ty.

Hầu hết VPN hoạt động bằng cách sử dụng phần payload của Transport layer.
![](/assets/images/vpn2.png)

* Phần payload của message gửi từ client sẽ được mang đến VPNs end point nơi mà tất cả các layer khác trừ network, transport và application bị bỏ đi.
* Phần payload lúc này sẽ được mã hóa để lại VPN server.
* Sau đó phần payload sẽ được encapsulated với data link layer đúng thông tin và gửi ra đâu đó như thể từ private network của công ty.

##### Two-factor authentication
Là kỹ thuật dùng nhiều hơn username và password để authenticate.

Thông thường người ta dùng mã token được generate bởi người dùng thông qua 1 phần cứng hay phần mềm chuyên dụng nào đó.

![](/assets/images/vpn2.png)

Ngoài ra, người ta thường dùng VPN để thiết lập ``tunnel`` giữa 2 network của 2 tòa nhà với nhau (site-to-site connectivity) thông qua việc kết nối router hoặc thiết bị VPN chuyên dụng trên 1 mạng đến 1 router trên mạng khác.
&gt; Từ đó network của 2 toà nhà có thể truy cập resource của toà nhà còn lại mà ko bị chặn.

Tóm lại, VPN là 1 công nghệ tạo tunnel mã hóa để cho phép remote network hoặc 1 máy tính hoạt động như thể nó được kết nối vật lý đến 1 network nào đó.

#### Proxies 
Dịch vụ proxy là 1 server đại diện cho client để access 1 service khác. 
Nó ngồi giữa client và các servers khác.

1 số lợi ích của proxy:
* Anonymity: ẩn danh
* Security: bảo mật
* Content filtering: lọc nội dung
* Increased performance: tăng hiệu suất

Gateway router là 1 ví dụ cho proxy. Proxy là khái niệm trừu tượng và nó hiện diện ở bất cứ layer nào.

##### Web proxy
* Lúc trước dùng để caching data giúp truy xuất lại nhanh hơn vì web proxy là cái sẽ đại diện cho client để truy xuất data từ service. Thời nay ít được dùng vì các tổ chức có khả năng xử lý mạnh mẽ nên không cần nữa. 


* Hiện nay web proxy được sử dụng để ngăn chặn 1 ai đó truy cập vào các trang web. 
Ví dụ: công ty chặn nhân viên vào facebook trong giờ làm việc để tăng năng suất.
![](/assets/images/web-proxy.png)

##### Reverse proxy
Là 1 dịch vụ như là 1 server độc lập nhưng thực chất đại diện cho nhiều server đằng sau nó.

Ví dụ: 

* Tất cả traffic sẽ được kết nối đến 1 máy chủ web server của Twitter (gọi là reverse proxy) sẽ có nhiều web server sống phía sau nó để giúp quản lý số lượng lớn các request.

Proxy server sẽ phân phối đến các app server theo hình thức Round robin để đảm bảo load balancing như DNS.

 ![](/assets/images/reverse -proxy.png)
 
* Một ứng dụng khác là để giải mã. Lúc này các application server chỉ cần phục vụ việc show web, còn lại proxy server lo. 


### Một số định nghĩa khác cần nắm:

* ``Traceroute`` và ``mtr``: là 1 tính năng cho phép thấy đường đi giữa 2 nodes, và cho thông tin về mỗi hop trên đường đi.
Nó dùng kỹ thuật thông minh tại TTl field ở IP level. Đặt TTL đầu tiên là 1 và tăng dần giúp xác định lỗi nằm ở bước hop nào.
 ![](/assets/images/traceroute.png)
 
 Traceroute ở mỗi bước sẽ gửi 3 gói tin, số đầu mỗi dòng là số thứ tự hop. 
  ![](/assets/images/traceroute2.png)
 
 ``mtr`` cũng tương tự nhưng chạy thời gian thực và thấy rõ hơn các thay đổi, liên tục cập nhật data tổng hợp được về traceroute.
 
* Netcat/Test-NetConnection: để xem tầng transport có đang hoạt động không.
Cú pháp: ``nc host port``

Cách hoạt động: câu lệnh sẽ cố thiết lập kết nối tới port X của webserver (gửi data từ tầng app đến listening service).
	* Nếu kết nối thành công: 1 con trỏ nháy đầu dòng xuất hiện đợi input.
	* Nếu kết nối thất bại: câu lệnh sẽ dừng.

=&gt; Nếu muốn không cần input chỉ để biết trạng thái thì thêm flag ``-z `v`` nghĩa là Zero input/output mode và verbose.

* Name resolution tool: 
``nslookup &lt;webserver_optional&gt;`` để trả về  record tra cứu lỗi.
&gt;Hoặc có thể nhập nslookup rồi nhập tiếp trong env của nó. Ví dụ:
</code></pre>
<blockquote>
  <p>webserver
set type=MX (loại tài nguyên)
set debug (thêm chi tiết)
```</p>
  <ul>
    <li>Public DNS server: là các name server được thiết lập đặc biệt để bất cứ ai cũng có thể sử dụng miễn phí. Ví dụ 8.8.8.8 và 8.8.4.4 của Google</li>
  </ul>
</blockquote>

<p>Lưu ý dùng của các công ty uy tín tránh bị attack. Nếu không phải debug thì nên dùng name server cung cấp bởi ISP của bạn.
<img src="/assets/images/DNS-attack.png" alt="" /></p>

<ul>
  <li>DNS Registration &amp; expiration
Registrar là 1 tổ chức có nhiệm vụ giao domain name cho tổ chức hoặc cá nhân.</li>
</ul>

<p>Mua domain name:
	* Đăng ký tài khoản trên trang của registrar
	* Tìm tên miền muốn mua
	* Đồng ý với số tiền và thời hạn sử dụng
	* Thanh toán
	* Ghi nhớ HSD mà gia hạn trước thời gian hết hạn.</p>

<p>Ngoài ra ta có thể transfer domain giữa các registrar và cá nhân:
<img src="/assets/images/transfer-domain.png" alt="" />
	* Bên nhận generate 1 chuỗi ký tự độc nhất để gửi cho bên transfer.
	* Bên transfer sẽ ghi cùng chuỗi ký tự đó trên 1 text record được cấu hình trong DNS setting để xác nhận là họ sở hữu domain này và được phép transfer.
	* Hai bên chấp thuận trao đổi quyền sở hữu.</p>

<ul>
  <li>Host files
Là flat file chứa trên mỗi dòng, 1 địa chỉ network đi theo bởi host name.
Nói cách khác nó cho phép máy tính cá nhân cho rằng 1 tên miền luôn trỏ vào 1 IP cụ thể.</li>
</ul>

<p>Ví dụ: 1.2.3.4 webserver</p>

<h3 id="interview-sample">Interview sample</h3>

<p>Tình huống: nhân viên nội bộ truy cập URL nội bộ của công ty gặp lỗi “Trang không hiển thị được”.</p>

<p>Quy trình debug có thể tham khảo như sau:</p>
<ul>
  <li>Hỏi xem thông báo lỗi là gì.</li>
  <li>Hỏi xem người khác có vào được ko.</li>
  <li>Xin tên web để thử tra cứu trên máy mình.</li>
  <li>Nói user thử truy cập trang web khác.</li>
  <li>Hỏi user dùng os nào và hướng dẫn nhập lệnh ifconfig. Kết quả là 1 loạt các thông số sau:
```</li>
  <li>IP: là 1 địa chỉ duy nhất được cấp cho máy tính để giao tiếp trên Internet với các máy tính khác.</li>
  <li>Default gateway: như 1 điểm truy cập được máy tính sử dụng để chia sẻ thông tin với 1 máy tính khác hoặc trên Internet, có thể xem như là 1 router.</li>
  <li>DNS: là domain name system dịch domain name thành IP.</li>
  <li>
    <p>DHCP: giúp tự động cấp địa chỉ IP cho máy tính và gửi cấu hình mạng cho máy tính.
```
=&gt; phát hiện IP range của network là 172.x.x.x nhưng IP của máy tính lại là 192.x.x.x.</p>
  </li>
  <li>
    <p>Hỏi xem máy tính có dùng DHCP không? (nên dùng để tự động cấp phát)
=&gt; Có thể do mình cấu hình IP tĩnh cho máy nên không truy cập được, cần vào DHCP settings để điều chỉnh cho gán tự động.
=&gt; Cũng có thể DHCP cấu hình sai hoặc kết nối với mạng sai nên địa chỉ IP bị sai range.</p>
  </li>
  <li>Hỏi xem đang kết nối mạng dây hay không dây. Nếu laptop hay điện thoại thì không dây (wi-fi).
=&gt; Kiểm tra wifi đang kết nối mạng nào, có phải mạng công ty không.
=&gt; Lỗi do kết nối mạng ngoài đường không phải mạng công ty.</li>
</ul>

<p>Tóm lại, luôn tìm ra lỗi nằm ở đâu trước khi vào sửa nó.</p>

</div>

<!-- Rating -->


<!-- Author Box if enabled from _config.yml -->
<!-- Author Box -->


<div class="authorbox mb-5 mt-5 pt-4 pb-4">   
    <div class="row">
        <div class="wrapavname col-md-3 text-center">
            
            <img  class="author-thumb" src="/assets/images/ava.png" alt="Tuyen">
            
            <p class="mt-4 mb-0 small text-center">
                <a target="_blank" class="d-inline-block mx-1 text-dark" href="https://www.tuyen-nnt.github.io"><i class="fa fa-link"></i></a> 
                <a target="_blank" class="d-inline-block mx-1 text-dark" href=""><i class="fab fa-twitter"></i></a>
                <a class="d-inline-block mx-1 text-dark" href="mailto:tuyendev96@gmail.com"><i class="fa fa-envelope"></i></a>
            </p>
        </div>
        <div class="col-md-9">
            <h4>Tuyen</h4>
            <p class="mt-3 mb-0">Author of this blog, mostly about Technical which is the field I am interested in.</p>
        </div>
    </div> 
</div> 



<!-- Comments if not disabled with comments: false -->
<!-- Comments
================================================== -->
 
<div class="comments mt-5">
    <button class="btn btn-outline-dark py-2 px-5 d-block w-100 show-comments"><i class="fa fa-comments text-muted"></i> &nbsp; Load Comments</button>         
    <div id="comments">  
        <h4 class="mb-4">Comments</h4>                 
            <section class="disqus">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'demowebsite'; 
        var disqus_developer = 0;
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = window.location.protocol + '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</section>
     
    <div class="clearfix"></div>              
    </div>    
</div>       


<!-- Share -->
<div class="share">
    <p>
        Share
    </p>
    <ul>
        <li class="ml-1 mr-1">
            <a target="_blank" href="https://twitter.com/intent/tweet?text=Tìm hiểu Network&url=https://tuyen-nnt.github.io/network/" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                <i class="fab fa-twitter"></i>
            </a>
        </li>

        <li class="ml-1 mr-1">
            <a target="_blank" href="https://facebook.com/sharer.php?u=https://tuyen-nnt.github.io/network/" onclick="window.open(this.href, 'facebook-share', 'width=550,height=435');return false;">
                <i class="fab fa-facebook-f"></i>
            </a>
        </li>

        <li class="ml-1 mr-1">
            <a target="_blank" href="https://www.linkedin.com/shareArticle?mini=true&url=https://tuyen-nnt.github.io/network/" onclick="window.open(this.href, 'width=550,height=435');return false;">
                <i class="fab fa-linkedin-in"></i>
            </a>
        </li>

    </ul>
</div>


<!-- Related Post -->
<!-- Related Posts
================================================== -->
<div class=" related-posts ">  

    
    <h2 class="text-center mb-4">Explore more like this</h2>
    
    
    <div class="d-flex justify-content-center align-items-center">
    
    <!-- Categories -->
    
    
    <a class="smoothscroll badge badge-primary text-capitalize" href="/categories#Network">Network</a>                
    

    <!-- Tags -->  
    
    

    </div>

    
    
    
    <div class="blog-grid-container">
        
        
            
            
        
            
        
            
        
        
        
            
            
        
            
        
            
        
        
        
            
            
        
            
        
            
        
        
        
            
            
        
            
        
            
        
        
        
            
            
        
            
        
            
        
        
        
            
            
        
            
        
            
        
        
        
            
            
        
            
        
            
        
        
        
            
            
        
            
        
            
        
        
        
            
            
        
            
        
            
        
        
        
            
            
        
            
        
            
        
        
        
            
            
        
            
        
            
        
        
        
            
            
        
            
        
            
        
        
        
            
            
        
            
        
            
        
        
        
            
            
        
            
        
            
        
        
        
            
            
        
            
        
            
        
        
        
            
            
        
            
        
            
        
        
        
            
            
        
            
        
            
        
        
        
            
            
        
            
        
            
        
        
        
            
            
        
            
        
            
        
        
        
            
            
        
            
        
            
        
        
        
            
            
        
            
        
            
        
        
        
            
            
        
            
        
            
        
        
        
            
            
        
            
        
            
        
        
        
            
            
        
            
        
            
        
        
        
            
            
        
            
        
            
        
        
        
            
            
        
            
        
            
        
        
        </div>        
</div>

<!-- Review with LD-JSON, adapt it for your needs if you like, but make sure you test the generated HTML source code first: 
https://search.google.com/structured-data/testing-tool/u/0/
================================================== -->

    </div>

    
    <!-- Newsletter
    ================================================== -->
    <div class="newsletter text-center">
        <span class="h4"><img src="/assets/images/ava.png" class="newsletter-logo" alt="My Blog"> &nbsp; Never miss a <b>story</b> from us, subscribe to our newsletter</span>
        <form action="https://wowthemes.us11.list-manage.com/subscribe/post?u=8aeb20a530e124561927d3bd8&amp;id=8c3d2d214b" method="post" name="mc-embedded-subscribe-form" class="wj-contact-form validate" target="_blank" novalidate>
            <div class="mc-field-group d-inline-flex">
            <input type="email" placeholder="Your e-mail" name="EMAIL" class="required email" id="mce-EMAIL" autocomplete="on" required>
            <input type="submit" value="Subscribe" name="subscribe" class="heart">
            </div>
        </form>
    </div>
    
    
</div>

<!-- Begin Footer
================================================== -->
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-12 text-center text-lg-left">
                Copyright © 2022 Tuyen Nguyen 
            </div>
            <div class="col-md-6 col-sm-12 text-center text-lg-right">    
                <a target="_blank" href="https://www.wowthemes.net/memoirs-free-jekyll-theme/">Memoirs Jekyll Theme</a> by WowThemes.net
            </div>
        </div>
    </div>
</footer>
<!-- End Footer
================================================== -->

</div> <!-- /.site-content -->

<!-- Scripts (if you need bootstrap.js, please add it yourself. I didn't use it for performance reasons, it was not needed in this theme)
================================================== -->

<script src="/assets/js/prism.js"></script>

<script src="/assets/js/theme.js"></script>




<script id="dsq-count-scr" src="//demowebsite.disqus.com/count.js"></script>


</body>
</html>
